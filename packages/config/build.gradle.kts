@file:OptIn(org.jetbrains.kotlin.gradle.ExperimentalWasmDsl::class)

import com.github.gmazzo.buildconfig.BuildConfigField
import com.github.gmazzo.buildconfig.BuildConfigValue
import com.github.gmazzo.buildconfig.BuildConfigTask
import com.github.gmazzo.buildconfig.generators.BuildConfigGenerator
import com.github.gmazzo.buildconfig.generators.BuildConfigGeneratorSpec
import com.github.gmazzo.buildconfig.generators.BuildConfigKotlinGenerator
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.TypeSpec
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import kotlinx.serialization.json.*
import java.io.FileOutputStream
import java.util.Properties
import java.nio.charset.Charset
import GenstackBuild as Constants

plugins {
  `maven-publish`
  `jvm-toolchains`
  alias(libs.plugins.nexus)
  alias(libs.plugins.android.library)
  alias(libs.plugins.newco.kmp)
  alias(libs.plugins.idea.ext)
  alias(libs.plugins.newco.root)
  alias(libs.plugins.buildconfig)
}

val apiVersion = "v1"

java {
  sourceCompatibility = GenstackBuild.javaVersion
  targetCompatibility = GenstackBuild.javaVersion

  toolchain {
    vendor = GenstackBuild.androidToolchainVendor
    languageVersion = GenstackBuild.androidToolchainVersion
  }
}

val generatedWarning = "Generated by build; do not edit manually"
val generatedConstantsGroup = "${Constants.mavenGroup}.api.config"
val generatedConstantsClass = "Constants"

kotlin {
  explicitApi()
  androidTarget()

  jvm { configureJvmTarget() }
  js { configureJsTarget() }

  if (GenstackBuild.wasm) wasmJs {
    configureJsTarget()
  }
  if (GenstackBuild.wasi) wasmWasi {
    nodejs()
  }
  if (GenstackBuild.enableiOS) {
    iosArm64()
    iosSimulatorArm64()
  }
  if (GenstackBuild.enableArm64) {
    macosArm64()
    linuxArm64()
  }
  if (GenstackBuild.enableX64) {
    macosX64()
    linuxX64()
    mingwX64()
  }

  sourceSets {
    commonMain.dependencies {
      // Nothing yet.
    }
    commonTest.dependencies {
      implementation(kotlin("test"))
    }
    androidMain.dependencies {
      // Nothing yet.
    }
    jvmMain.dependencies {
      // Nothing yet.
    }
  }
}

android {
  compileSdk = GenstackBuild.androidCompileTarget
  namespace = androidNamespace("config")
  sourceSets["main"].manifest.srcFile("src/androidMain/AndroidManifest.xml")

  defaultConfig {
    minSdk = GenstackBuild.androidMinSdk
  }
  compileOptions {
    sourceCompatibility = GenstackBuild.javaVersion
    targetCompatibility = GenstackBuild.javaVersion
  }
}

buildConfig {
  generator = object : BuildConfigKotlinGenerator() {
      override fun adaptSpec(spec: TypeSpec) = spec.toBuilder()
          .addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("kotlin.js.JsName"))
              .addMember("name = %S", spec.name!!)
              .build())
          .build()
  }

  className("Config")
  packageName(generatedConstantsGroup)
  documentation = generatedWarning
  useKotlinOutput { internalVisibility = false }

  buildConfigField("VERSION", provider { project.version as String })

  // declare `Constants`
  forClass(generatedConstantsClass) {
    documentation = generatedWarning
    buildConfigField("API_VERSION", provider { apiVersion })
  }

  sourceSets.named("jvmMain") {
    useKotlinOutput { internalVisibility = false }
    documentation = generatedWarning
    className("PlatformConfig")
    buildConfigField("PLATFORM", "jvm")
  }

  sourceSets.named("jsMain") {
    useKotlinOutput { internalVisibility = false }
    documentation = generatedWarning
    className("PlatformConfig")
    buildConfigField("PLATFORM", "js")
  }
}

val jsonFile = provider {
  layout.buildDirectory.file("gen/master.json")
    .get()
    .getAsFile()
}

val sources = arrayOf(
  layout.projectDirectory.file("src/master.pkl"),
)

tasks {
  val constantsJson by registering(Exec::class) {
    // for example: `pkl eval -f json ./src/master.pkl`
    val outfile = layout.buildDirectory.file("gen/master.json").get().getAsFile()
    executable = "pkl"

    args = mutableListOf<String>(
      "eval",
      "--format", "json",
      "--output-path", outfile.absolutePath.toString(),
    ).plus(
      sources.map { it.asFile.absolutePath.toString() }
    )

    inputs.files(sources.map { it.asFile })
    outputs.file(outfile)
  }

  // --- Constants
  buildConfig.forClass(
    className = generatedConstantsClass,
    packageName = generatedConstantsGroup,
  ) {
      buildConfigFields.addAllLater(provider {
        val fields = mutableListOf<BuildConfigField>()
        val fileAsJsonObject = Json.decodeFromString<JsonObject>(jsonFile.get().readText(Charset.defaultCharset()))
        fileAsJsonObject.forEach {
          val name = it.key
          val path = it.value.jsonPrimitive.content
          if (path.isBlank()) {
              throw IllegalArgumentException("Path for $name is empty")
          }
          fields.add(objects.newInstance<BuildConfigField>(name).apply {
            type(String::class)
            expression("\"$path\"")
          })
        }
        fields
      })
  }

  val constants by registering {
    dependsOn(constantsJson, withType<BuildConfigTask>())
  }

  afterEvaluate {
    withType<KotlinCompile>().configureEach {
      dependsOn(constantsJson)
    }
    withType<BuildConfigTask>().configureEach {
      dependsOn(constantsJson)
    }
  }
}

configureKmpProject()
publishableKmpLib()
